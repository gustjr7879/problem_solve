11주차 (bfs)

dp 다음으로 가장 자신없는 .. 하지만 단골문제이기때문에 언제까지나 피할 수 없는 부분이다.

2264 - 촌수계산

이 문제는 전형적인 bfs문제라고 느껴졌고 접근법을 생각해보았다.

bfs는 queue를 이용하여 푸는 것이 일반적이고 기본적인 bfs를 만든 후 변형시켜가면서 풀어나가는 풀이가 많다고 한다.
그래서 기본적인 bfs구현을 먼저 공부하고 연습했고,
덕분에 python에서 가장 귀찮다고 느껴졌던 dict 안에 set이나, list, list안에 list를 연습할 기회가 생겼다.

2644 풀이는 파일로 올려놨으며 
풀이방식은
1. 기본적인 변수 선언
2. 그래프 생성(이 문제에서는 list in list)
3. check list생성 (몇번을 거쳐야지 갈 수 있는지 체크)
4. bfs구현 및 내부에 check 리스트 만들어줌
5. 결과 출력


으로 진행하였다.
내부적으로 살펴보면, queue에 루트(시작) 노드를 추가해주고, 그래프 리스트에 담겨있는(시작 노드에서 연결될 수 있는) 노드들을 대상으로 check리스트에 0이면 check리스트에 출발 노드를 적어둔다
그리고 방문한 노드를 queue에 넣어줌
이걸 반복하게 되면 어떻게 되냐면 순차적으로 1씩 더해져서 얼마나 멀리있는지 확인할 수 있어서 이 문제의 답이 되게 된다.


14942 - 개미


사실 어려워보여서 안풀라고했는데 다른 문제 푸는것 보단 나을 것 같아서 풀기시작함
오기 생겨가지고 계속 안풀려도 계속 풀었는데 처음엔 BFS로 접근하다가 몇번 거쳐서 가는거 까지는 나왔는데 조금 더 고민했다면 bfs로도 풀 수 있었을 것 같음
근데 눈썹 밀리기 싫어서 다익스트라로 변경해서 풀기시작함

모든 굴의 종착점인 1번 방에서 시작해서 역으로 모든 방을 도착점으로 삼아서 진행함

다익스트라에서 최단 거리 갱신이 일어나는 부분에서 x방을 방문하기 전 방문했던 방을 n번째 인덱스에 저장하는 path를 추가함

1번방은 움직이지 않아도 되므로 result 에서 1을 추가했으며
밑에서 다익스트라와 path를 갱신하는 코드를 작성해줬음

dist계산하는 것은 평소에 작성하던 코드에서 가져와서 작성했고 다음 방으로 갈때 인접한 굴 중 가장 짧은 거리를 cur라는 변수에 담고 비교하면서 짧은 거리로 가게 함
예시에서 다 cost가 10이여서 테스트할땐 101010 987으로 나눠서 차이날때도 성립이 되는지 체크함

nextdist 변수는 distance에서 가는 cost를 더해줘서 짧은 거리를 갈 수 있게 함


다음은 다익스트라를 1번방으로 돌리고 
2번방부터~ 마지막 방까지 그 안에서 최단 거리 방이 맞으면 에너지 소모량 저장시켜놓음

1번방일 경우는 예외처리 한 후 지속적으로 path 배열을 타고 올라가다가 에너지가 0이하가 되면 정답을 리턴하게 만들었음

시간이 매우 오래걸렸음 bfs
